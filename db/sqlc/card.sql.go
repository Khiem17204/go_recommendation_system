// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: card.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createCard = `-- name: CreateCard :one
INSERT INTO cards (
  id,
  name,
  type,
  frame_type,
  archetype,
  attribute,
  race,
  level,
  attack,
  defense,
  description,
  raw_card_info
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12
) RETURNING id, name, type, frame_type, archetype, attribute, race, level, attack, defense, description, raw_card_info
`

type CreateCardParams struct {
	ID          int64           `json:"id"`
	Name        string          `json:"name"`
	Type        string          `json:"type"`
	FrameType   string          `json:"frame_type"`
	Archetype   sql.NullString  `json:"archetype"`
	Attribute   sql.NullString  `json:"attribute"`
	Race        sql.NullString  `json:"race"`
	Level       sql.NullInt32   `json:"level"`
	Attack      sql.NullInt32   `json:"attack"`
	Defense     sql.NullInt32   `json:"defense"`
	Description string          `json:"description"`
	RawCardInfo json.RawMessage `json:"raw_card_info"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.FrameType,
		arg.Archetype,
		arg.Attribute,
		arg.Race,
		arg.Level,
		arg.Attack,
		arg.Defense,
		arg.Description,
		arg.RawCardInfo,
	)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.FrameType,
		&i.Archetype,
		&i.Attribute,
		&i.Race,
		&i.Level,
		&i.Attack,
		&i.Defense,
		&i.Description,
		&i.RawCardInfo,
	)
	return i, err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards
WHERE id = $1
`

func (q *Queries) DeleteCard(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const getCard = `-- name: GetCard :one
SELECT id, name, type, frame_type, archetype, attribute, race, level, attack, defense, description, raw_card_info FROM cards 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCard(ctx context.Context, id int64) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.FrameType,
		&i.Archetype,
		&i.Attribute,
		&i.Race,
		&i.Level,
		&i.Attack,
		&i.Defense,
		&i.Description,
		&i.RawCardInfo,
	)
	return i, err
}

const listCards = `-- name: ListCards :many
SELECT id, name, type, frame_type, archetype, attribute, race, level, attack, defense, description, raw_card_info FROM cards
ORDER BY id
LIMIT $1 
OFFSET $2
`

type ListCardsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCards(ctx context.Context, arg ListCardsParams) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Card{}
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.FrameType,
			&i.Archetype,
			&i.Attribute,
			&i.Race,
			&i.Level,
			&i.Attack,
			&i.Defense,
			&i.Description,
			&i.RawCardInfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
